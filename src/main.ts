import { BinaryReader } from "@sevenc-nanashi/binaryseeker";
import * as fs from "node:fs/promises";
import * as parser from "./parser.ts";

async function main() {
  const buffer = await fs.readFile("./__gi_font/Firple-Regular.ttf");
  const arrayBuffer = buffer.buffer.slice();
  const reader = new BinaryReader(arrayBuffer);

  const fontDir = parser.readDirectory(reader);
  const hheaOffset = findOffset(fontDir.tables, "hhea");
  const hheaTable = parser.readHhea(reader, hheaOffset);
  const maxpOffset = findOffset(fontDir.tables, "maxp");
  const maxpTable = parser.readMaxp(reader, maxpOffset);
  const hmtxOffset = findOffset(fontDir.tables, "hmtx");
  const hmtxTable = parser.readHmtx(
    reader,
    hmtxOffset,
    maxpTable.numGlyphs,
    hheaTable.numberOfHMetrics,
  );

  const cmapOffset = findOffset(fontDir.tables, "cmap");
  const cmapTable = parser.readCmap(reader, cmapOffset);
  const charToGlyphId = new Map();
  const glyphIdToChar = new Map();
  for (const record of cmapTable.encodingRecords) {
    console.log(
      `Platform ID: ${record.platformId}, Encoding ID: ${record.encodingId}, Format: ${record.subTable?.format}`,
    );
    if (!record.subTable || !record.subTable.glyphIndexMap) {
      continue;
    }

    for (const [key, value] of record.subTable.glyphIndexMap.entries()) {
      charToGlyphId.set(key, value);
      glyphIdToChar.set(value, key);
    }
  }

  const advanceWidths = new Map<number, Set<string>>();
  for (const [char, glyphId] of charToGlyphId.entries()) {
    const advanceWidth =
      hmtxTable.advanceWidth[
        Math.min(glyphId, hmtxTable.advanceWidth.length - 1)
      ];
    const charCode = char.charCodeAt(0);
    if (charCode < 0x80) {
      continue; // setcellwidths does not support ASCII characters
    }
    if (advanceWidth === 0) {
      continue;
    }
    if (!advanceWidths.has(advanceWidth)) {
      advanceWidths.set(advanceWidth, new Set());
    } else {
      const existingSet = advanceWidths.get(advanceWidth)!;
      existingSet.add(char);
    }
  }
  if (advanceWidths.size !== 2) {
    console.error(
      `Expected 2 advance widths, found ${advanceWidths.size}. This is likely not a valid monospace font.`,
    );
    return;
  }
  console.log("Advance Widths:");

  const output: string[] = [];
  const nonce = Math.random().toString(36).substring(2, 15);
  output.push(`" This file is generated by cellwidths_gen`);
  output.push(`if exists('g:cellwidths_gen_${nonce}')`);
  output.push(`  finish`);
  output.push(`endif`);
  output.push(`let g:cellwidths_gen_${nonce} = 1`);
  output.push(`if !exists('g:cellwidths_gen_current')`);
  output.push(`  let g:cellwidths_gen_current = 'none'`);
  output.push(`endif`);

  const smallerWidth = Math.min(...advanceWidths.keys());
  const largerWidth = Math.max(...advanceWidths.keys());

  output.push(`let s:cellwidths = [`);
  for (const [width, chars] of advanceWidths.entries()) {
    const charCodes = Array.from(chars).map((c) => c.codePointAt(0) || 0);
    charCodes.sort((a, b) => a - b);
    const segments = [[charCodes[0], charCodes[0]]];
    for (const charCode of charCodes.slice(1)) {
      const lastSegment = segments[segments.length - 1];
      if (charCode === lastSegment[1] + 1) {
        lastSegment[1] = charCode; // Extend the segment
      } else {
        segments.push([charCode, charCode]); // Start a new segment
      }
    }

    for (const segment of segments) {
      const start = segment[0];
      const end = segment[1];
      const widthValue = width === smallerWidth ? 1 : 2;
      output.push(`\\ [${start}, ${end}, ${widthValue}],`);
    }
  }
  output.push(`\\ ]`);
  output.push(`augroup cellwidths_gen_${nonce}`);
  output.push(`  autocmd!`);
  output.push(`  autocmd OptionSet guifont call s:update_cellwidths()`);
  output.push(`augroup END`);
  output.push(`function! s:update_cellwidths() abort`);
  output.push(`  if g:cellwidths_gen_current != '${nonce}'`);
  output.push(`    let g:cellwidths_gen_current = '${nonce}'`);
  output.push(`    call setcellwidths(s:cellwidths)`);
  output.push(`  endif`);
  output.push(`endfunction`);
  output.push(`call s:update_cellwidths()`);

  const outputPath = "./cellwidths.vim";
  await fs.writeFile(outputPath, output.join("\n"));
}

function findOffset(tables: parser.Table[], tag: string): number {
  const table = tables.find((t) => t.tag === tag);
  if (!table) {
    throw new Error(`Table with tag ${tag} not found`);
  }
  return table.offset;
}

main();
