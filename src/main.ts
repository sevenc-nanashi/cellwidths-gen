import * as fs from "node:fs/promises";
import { BinaryReader } from "@sevenc-nanashi/binaryseeker";
import * as parser from "./parser.ts";

async function main() {
  const fontFilePath = process.argv[2];
  if (!fontFilePath) {
    console.error("Usage: bun run src/main.ts <font_file_path>");
    process.exit(1);
  }
  const buffer = await fs.readFile(fontFilePath);
  const arrayBuffer = buffer.buffer.slice();
  const reader = new BinaryReader(arrayBuffer);

  const { hheaTable, maxpTable, hmtxTable, cmapTable } =
    await readFontData(reader);
  function processCmapTable(cmapTable: parser.CmapTable) {
    const charToGlyphId = new Map<string, number>();
    const glyphIdToChar = new Map<number, string>();
    for (const record of cmapTable.encodingRecords) {
      console.log(
        `Platform ID: ${record.platformId}, Encoding ID: ${record.encodingId}, Format: ${record.subTable?.format}`,
      );
      if (!record.subTable || !record.subTable.glyphIndexMap) {
        continue;
      }

      for (const [key, value] of record.subTable.glyphIndexMap.entries()) {
        charToGlyphId.set(key, value);
        glyphIdToChar.set(value, key);
      }
    }
    return { charToGlyphId, glyphIdToChar };
  }

  const { charToGlyphId, glyphIdToChar } = processCmapTable(cmapTable);

  function calculateAdvanceWidths(
    charToGlyphId: Map<string, number>,
    hmtxTable: parser.HmtxTable,
  ): Map<number, Set<string>> {
    const advanceWidths = new Map<number, Set<string>>();
    for (const [char, glyphId] of charToGlyphId.entries()) {
      const advanceWidth =
        hmtxTable.advanceWidth[
          Math.min(glyphId, hmtxTable.advanceWidth.length - 1)
        ];
      const charCode = char.charCodeAt(0);
      const ASCII_MAX_CODE = 0x80;

      // ... (inside calculateAdvanceWidths function)
      if (charCode < ASCII_MAX_CODE) {
        continue; // setcellwidths does not support ASCII characters
      }
      if (advanceWidth === 0) {
        continue;
      }
      if (!advanceWidths.has(advanceWidth)) {
        advanceWidths.set(advanceWidth, new Set());
      }
      advanceWidths.get(advanceWidth)?.add(char);
    }
    return advanceWidths;
  }

  const advanceWidths = calculateAdvanceWidths(charToGlyphId, hmtxTable);
  if (advanceWidths.size !== 2) {
    console.error(
      `Expected 2 advance widths, found ${advanceWidths.size}. This is likely not a valid monospace font.`,
    );
    return;
  }
  console.log("Advance Widths:");

  function generateVimScript(advanceWidths: Map<number, Set<string>>): string {
    const output: string[] = [];
    const nonce = Math.random().toString(36).substring(2, 15);
    output.push(`" This file is generated by cellwidths_gen`);
    output.push(`if exists('g:cellwidths_gen_${nonce}')`);
    output.push(`  finish`);
    output.push(`endif`);
    output.push(`let g:cellwidths_gen_${nonce} = 1`);
    output.push(`if !exists('g:cellwidths_gen_current')`);
    output.push(`  let g:cellwidths_gen_current = 'none'`);
    output.push(`endif`);

    const smallerWidth = Math.min(...advanceWidths.keys());
    const _largerWidth = Math.max(...advanceWidths.keys());

    output.push(`let s:cellwidths = [`);
    for (const [width, chars] of advanceWidths.entries()) {
      const charCodes = Array.from(chars).map((c) => c.codePointAt(0) || 0);
      charCodes.sort((a, b) => a - b);
      const segments = [[charCodes[0], charCodes[0]]];
      for (const charCode of charCodes.slice(1)) {
        const lastSegment = segments[segments.length - 1];
        if (charCode === lastSegment[1] + 1) {
          lastSegment[1] = charCode; // Extend the segment
        } else {
          segments.push([charCode, charCode]); // Start a new segment
        }
      }

      for (const segment of segments) {
        const start = segment[0];
        const end = segment[1];
        const widthValue = width === smallerWidth ? 1 : 2;
        output.push(`\\ [${start}, ${end}, ${widthValue}],`);
      }
    }
    output.push(`\\ ]`);
    output.push(`augroup cellwidths_gen_${nonce}`);
    output.push(`  autocmd!`);
    output.push(`  autocmd OptionSet guifont call s:update_cellwidths()`);
    output.push(`augroup END`);
    output.push(`function! s:update_cellwidths() abort`);
    output.push(`  if g:cellwidths_gen_current != '${nonce}'`);
    output.push(`    let g:cellwidths_gen_current = '${nonce}'`);
    output.push(`    call setcellwidths(s:cellwidths)`);
    output.push(`  endif`);
    output.push(`endfunction`);
    output.push(`call s:update_cellwidths()`);

    return output.join("\n");
  }

  const vimScriptContent = generateVimScript(advanceWidths);
  const outputPath = "./cellwidths.vim";
  await fs.writeFile(outputPath, vimScriptContent);
}

function findOffset(tables: parser.Table[], tag: string): number {
  const table = tables.find((t) => t.tag === tag);
  if (!table) {
    throw new Error(`Table with tag ${tag} not found`);
  }
  return table.offset;
}

async function readFontData(reader: BinaryReader) {
  const fontDir = parser.readDirectory(reader);
  const hheaOffset = findOffset(fontDir.tables, "hhea");
  const hheaTable = parser.readHhea(reader, hheaOffset);
  const maxpOffset = findOffset(fontDir.tables, "maxp");
  const maxpTable = parser.readMaxp(reader, maxpOffset);
  const hmtxOffset = findOffset(fontDir.tables, "hmtx");
  const hmtxTable = parser.readHmtx(
    reader,
    hmtxOffset,
    maxpTable.numGlyphs,
    hheaTable.numberOfHMetrics,
  );
  const cmapOffset = findOffset(fontDir.tables, "cmap");
  const cmapTable = parser.readCmap(reader, cmapOffset);

  return { fontDir, hheaTable, maxpTable, hmtxTable, cmapTable };
}

main();
